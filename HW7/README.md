# Итератор vs List<Episode>

## Преимущества использования паттерна Итератор:

1. **Инкапсуляция логики обхода**:
   - Итератор скрывает детали обхода коллекции, предоставляя простой интерфейс `hasNext()` и `next()`.
   - Это позволяет изменять способ обхода (например, в обратном порядке или случайным образом) без изменения кода, который использует итератор.

2. **Гибкость**:
   - Легко добавлять новые способы обхода (например, `ReverseSeasonIterator`, `ShuffleSeasonIterator`), не изменяя существующий код.
   - Это соответствует принципу открытости/закрытости (OCP) из SOLID.

3. **Универсальность**:
   - Итераторы могут работать с разными типами коллекций, не завися от их внутренней структуры.

4. **Безопасность**:
   - Итератор может предоставлять доступ только к чтению, предотвращая изменение коллекции во время обхода.

5. **Упрощение кода**:
   - Код, использующий итератор, становится чище и проще для понимания.

## Почему не просто возвращать List<Episode>?

- Если возвращать `List<Episode>`, то:
  - Пользователь должен сам писать логику обхода, что увеличивает вероятность ошибок.
  - Изменение способа обхода потребует изменения кода в нескольких местах.
  - Это нарушает принцип инкапсуляции, так как детали структуры коллекции становятся видимыми.

Использование паттерна Итератор делает код более модульным, гибким и устойчивым к изменениям.